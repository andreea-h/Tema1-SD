Pentru memorarea valorilor am definit o structura de tip lista simplu inlantuita denumita Point, cu trei campuri: value de tip double pentru memorarea valorilor, timestamp pentru momentul de timp si next pentru accesarea elementului urmator din lista. Am definit functia read care primeste ca parametru adresa de inceput a listei initializata cu NULL precum si numarul de elemente ce urmeaza a fi memorate in lista; in cadraul functiei read este apelata functia addLast; aceasta din urma este folosita pentru a adauga un nou element in lista, campurile value si timestamp primite la stdin fiind trimise ca argument functiei. Functia sizeOfList returNeza numarul de noduri continute intr-o lista primita ca parametru. Functia printVal afiseza elementele memorate in nodurile listei, precedate de numarul de elemente continute in lista, valoare obtinuta apeland functia sizeofList.

Pentru rezolvarea primului task din enunt (eliminare de exceptii folosind metode statistice), am parcurs lista citita si am memorat intr-o alta lista elementele din lista initiala care urmeaza a fi eliminate. Pentru identificarea si parcurgerea "ferestrelor" de cinci elemente, am definit functia subList care primeste ca parametru nodul din lista initiala incepand de la care se face numerorarea celor 5 noduri si intoarce adresa de inceput a unei 'subliste' cu 5 elemente. Pentru fiecare sublista de 5 elemente, generata pornind de la fiecare nod al listei initiale, am apelat functia media care calculeaza media aritmetica a valorilor din sublista, precum si functia middle care intoarce adresa elementului din mijlocul listei. Functia deviation calculeaza deviatia elementelor din subfereastra de 5 elemente primita ca paramteru, conform formulei din enunt. In cazul in care elementul din mijlocul ferestrei respecta conditiile de eliminare (fapt verificat in cadrul functiei validation care returneaza 1 daca conditia matematica de apartenenta la intervalul [media-deviation,media+deviation] este adevarata si 0 in sens contrat), elementul curent (memorat in mijlocul sublistei de 5 valori) este adaugat in lista valorilor care trebuie sterse, lista care are ca adresa de inceput pointerul memorat prin Point rez in cadrul functiei memExceptions. Operatia de stergere a elementelor din lista initiala se face in cadrul functiei modifyList care primeste 2 parametri: lst-adresa de inceput a listei initiale din care se elimina elementele si rez-adresa de inceput a listei care contine elementele care trebuie eliminate din lista lst. In cadrul functiei modifyList este parcursa lista care contine elementele care trebuie sterse si este apelata functia deleteItem (ce are ca parametri adresa de inceput a listei initiale si valoarea elemntului care trebuie modificat), pentru fiecare element din lista rez. In final se elibereaza memoria alocata pentru lista rez, precum si memoria alocata pentru acele noduri din lista initiala care au fost eliminate.

Pentru rezolvarea taskului 1.2.1 (ELiminarea de zgomot folosind filtrarea mediana), am definit functia mediana cu antetul Point mediana(Point lst). Aceasta returneza adresa de inceput a listei alcatuite din elementele plasate in mijlocul ferestrelor de 5 elemente generate in jurul fiecarui nod din lista initiala lst, primita ca parametru de functie. Pentru sortarea sublistelor de 5 elemente am definit functia recursiva MergeSort cu antetul 'void MergeSort(Point *lst)'. In cadrul functiei MergeSort am apelat functia part care primeste trei parametri: first - adresa de inceput a listei lst, si alte 2 adrese first1 si first2, initializate cu NULL la apelul functiei si care vor memora la finalul functiei part adresele de inceput pentru prima jumatate a listei lst respectiv pentru cea de-a doua jumatate a listei lst. Adresa catre care pointeaza first1 este egala cu adresa catre care pointeaza first, adresa de inceput a listei initiale. Pentru a determina adresa de inceput a mijlocului listei lst am folosit 2 pointeri aux1, initializat cu adresa de inceput a listei lst, si aux2 care este initializat cu al doilea element din lista lst. Pointerul aux1 se va deplasa in lista initiala astfel incat in momentul in care aux2 ajunge la finalul listei lst, aux1 va pointa catre nodul care preceda mijlocul listei lst. Astfel, aux1 se deplaseaza in lista la fiecare pas cu un singur nod pornind de la inceputul listei lst in timp ce aux2 se deplaseaza cu 2 'pozitii' pornind de la al doilea nod al listei lst. In cadrul functiei MergeSort, dupa apelul functiei part (pentru a memora in aux1 respectiv aux2 adresele de inceput pentru prima respectiv a doua jumatate a listei lst) am reapelat functia MergeSort pentru prima jumatate a listei initiale, respectiv pentru cea de-a doua jumatate a acesteia. Functia se va reapela pana cand se ajunge la situatia de punct fix (lista primita ca parametru de MergeSort va contine un singur element), iar apoi se vor interclasa listele formate dintr-un singur element in cadrul functiei merge. Functia recursiva merge primeste ca parametri adresele de inceput a 2 liste deja sortate si returneza adresa de inceput a listei care memoreaza nodurile celor 2 liste interclasate. 

Pentru rezolvarea taskului 1.2.2 (Eliminarea de zgomot folosind media aritmetica), am definit functia medie pentru a parcurge lista initiala si a genera in jurul fiecarui nod al acesteia o sublista de 5 elemente pentru care am calculat media aritmetica si am adaugat apoi elementul calculat la sfarsitul listei rez (initializata cu NULL). La final, functia medie returneaza adresa de inceput a listei rez.
Pentru rezolvarea taskului 1.3 al temei (uniformizarea frecventei in timp a datelor), am definit functia uniformisation in cadrul careia sunt modificate valorile pentru timestamp si value din lista initiala conform conditiilor din enuntul temei. Pentru a verifica daca elementul curent din lista trebuie modificat am definit functia interval cu antetul 'int interval(int a,int b)' care verifica daca diferenta temporala dintre 2 timestamp-uri consecutive este in intervalui [100,1000] milisecunde, returnand 1 in caz afirmativ si 0 in caz contrar. In cadrul functiei uniformisation am folosit 2 pointeri aux si pre (ambii pointand initial catre inceputul listei lst), apoi aux va memora adresa elementului curent din lista iar pre va memora adresa elementului precendent lui aux. In cazul in care diferenta temporala pentru datele memorate in aux si pre respecta conditiile de eliminare se modifica valorile pentru timestamp si value ale elementului curent.

Pentru rezolvarea taskului 1.4 (Completarea datelor), am definit functia fill care primeste ca parametru adresa de inceput a listei initiale si returneza lista finala in care s-au adugat valori conform conditiilor din enunt. Pentru a verifica daca urmeaza a fi introduse elemente in lista initiala, am definit 2 pointeri, aux si aux1, aux memorand adresa elementului curent din lista iar aux1 adresa elementului care il preceda pe aux. In cazul acelor noduri pentru care diferenta temporala fata de elementul precedent este mai mare de 1 secunda (aux->timestamp-aux1->timestamp>1000), am generat 2 subliste denumite right si left prin apelarea functiilor genRight si genLeft. Functia genRight cu antetul 'Point genRight(Point lst)' returneaza adresa de inceput a unei liste de 3 noduri situata dupa lst, nod primit ca parametru, cele 3 elemente memorate in lista right fiind in ordine inversa aparitiei lor in lista initiala (memorarea lor in lista right se face apeland functia addFirst).Functia genLeft primeste 2 parametri: adresa de inceput a listei initiale in care trebuie inserate elemente si adresa ultimului nod din lista de 3 elemente care se va memora incepand cu adresa left. In cadrul functiei genLeft se parcurge lista initiala pana la nodul situat cu 2 pozitii inaintea nodului care marcheaza sfarsitul listei left, apoi se adauga la finalul listei left urmatoarele 2 noduri din lista initiala si apoi nodul care indica ultimul element acesta fiind cel primit ca parametreu de functia genLeft. Pentru calculul valorii campului value al elementului care urmeaza a fi inserat in lista initiala am definit functia function_f care primeste ca parametru adresele de inceput ale listelor right si left, generate anterior, si valoarea timestamp a elementului care trebuie inserat in lista initiala. In functiei function_f valoarea campului value este calculata conform formulei din enuntul temei, apelandu-se functiile function_c pentru calcularea factorului de scalare si functia suma pentru calcularea sumelor prezente in formula.

Pentru rezolvarea cerintei 1.5 (statistici), am definit functia statistica cu antetul 'void statistica(Point lst,int delta)'. In cadrul acesteia am parcurs intervalul [-350,350] (valori considerate in urma analizei fisierelor de intrare) cu pasul delta primit ca argument in linia de comanda si am determinat pentru fiecare interval de forma [pas, pas+delta] (cu pas de la -350 la 350), numarul de aparitii al elementelor din lista in respectivul interval (numarul de aparitii este returnat de functia apparitions care primeste ca parametri adresa de inceput a listei si limitele intervalului curent; in cadrul acestei functii am parcurs elementele listei si am verificat prin comparatie ca capetele intervalului prezenta elementului respectiv in intervalul curent).



